# 应用功能编程原则

功能编程最近引起了主流编程社区的兴趣. 部分原因是因为功能范式的 *emergent properties* 能够很好地应对我们行业向多核转变所带来的挑战. 然而, 虽然这肯定是一个重要的应用程序, 但这并不是这篇文章告诫你 *了解你的函数式编程* 的原因.

掌握函数式编程范例可以极大地提高您在其他上下文中编写的代码的质量. 如果您深入理解并应用功能范例, 你的设计将表现出更高程度的 *引用透明度* .

引用透明性是一个非常理想的属性: 它意味着在相同的输入下, 函数始终产生相同的结果, 而不管它们在何时何地被调用. 也就是说, 功能评估对可变状态的副作用的影响较小(理想情况下, 完全不依赖).

命令式代码中缺陷的主要原因可归因于可变变量. 阅读本文的每个人都会调查为什么在特定情况下某些价值不如预期. 可见性语义可以帮助减轻这些潜在的缺陷, 或者至少大幅缩小它们的位置, 但它们的真正罪魁祸首实际上可能是采用过度可变性的设计的天意.

在这方面, 我们当然没有从行业那里获得太多帮助. 面向对象的介绍默认地促进了这种设计, 因为它们经常显示由相对长寿命的对象的图形组成的例子, 这些对象愉快地相互称为变换器方法, 这可能是危险的. 然而, 通过精确的测试驱动设计, 特别是在确定["Mock Roles, not Objects"](http://www.jmock.org/oopsla2004.pdf)时, 可以设计出不必要的可变性.

最终结果是: 一种设计通常具有更好的责任分配, 具有更多, 更小的函数, 这些函数作用于传递给它们的参数, 而不是引用可变成员变量. 缺陷将更少, 而且它们通常更容易调试, 因为更容易找到在这些设计中引入恶意值的位置, 而不是推断导致错误分配的特定上下文. 这相当于更高程度的引用透明度, 并且积极地没有任何东西可以将这些想法深深地融入您的骨骼中, 就像学习函数式编程语言一样, 这种计算模型是常态.

当然, 这种方法在所有情况下都不是最佳的. 例如, 在面向对象的系统中, 与用户界面开发相比, 这种风格通常会产生更好的结果, 即领域模型开发(即: 协作用于打破业务规则的复杂性).

掌握功能编程范例, 以便你能够明智地将学到的经验应用到其他领域. 你的对象系统(对于一个)会引起参考透明度的好处, 并且比你想象的更接近它们的功能对应物. 实际上, 有些人甚至断言函数式编程和面向对象的顶点只是*彼此的反映*, 一种计算阴阳的形式.

作者: [Edward Garson](http://programmer.97things.oreilly.com/wiki/index.php/Edward_Garson)

翻译: [Amao Zhao](https://blog.amaozhao.com)